'use client';

import { useState, useEffect, useCallback } from 'react';
import { getSupabase } from '@/lib/supabase';

// ============================================================
// CPA Portal Access Hook — D4n
// Role-based read-only access for CPA users, audit logging,
// export package generation, and CSV download utility
// ============================================================

export interface CPAAccessState {
  isCPA: boolean;
  isReadOnly: boolean;
  userEmail: string | null;
  loading: boolean;
}

export interface ExportPackageData {
  pnl: {
    revenue: ExportAccountRow[];
    cogs: ExportAccountRow[];
    expenses: ExportAccountRow[];
    totalRevenue: number;
    totalCogs: number;
    grossProfit: number;
    totalExpenses: number;
    netIncome: number;
  };
  balanceSheet: {
    assets: ExportAccountRow[];
    liabilities: ExportAccountRow[];
    equity: ExportAccountRow[];
    totalAssets: number;
    totalLiabilities: number;
    totalEquity: number;
  };
  trialBalance: {
    accounts: ExportAccountRow[];
    debitTotal: number;
    creditTotal: number;
    isBalanced: boolean;
  };
  vendors1099: {
    vendors: Export1099Vendor[];
    totalPayments: number;
    vendorCount: number;
  };
  watermark: string;
  generatedAt: string;
  dateRange: { startDate: string; endDate: string };
}

export interface ExportAccountRow {
  accountNumber: string;
  accountName: string;
  accountType: string;
  debits: number;
  credits: number;
  balance: number;
}

export interface Export1099Vendor {
  vendorName: string;
  taxId: string | null;
  ytdPayments: number;
  is1099Required: boolean;
}

// CSV escape: wrap values containing commas, quotes, or newlines in quotes
function escapeCSVValue(value: string | number | boolean | null): string {
  if (value === null || value === undefined) return '';
  const str = String(value);
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}

export function useCPAAccess() {
  const [isCPA, setIsCPA] = useState(false);
  const [isReadOnly, setIsReadOnly] = useState(false);
  const [userEmail, setUserEmail] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  // Check user role on mount
  useEffect(() => {
    const checkRole = async () => {
      try {
        const supabase = getSupabase();
        const { data: { user } } = await supabase.auth.getUser();

        if (user) {
          const role = user.app_metadata?.role as string | undefined;
          const email = user.email || null;
          setUserEmail(email);

          if (role === 'cpa') {
            setIsCPA(true);
            setIsReadOnly(true);
          } else {
            setIsCPA(false);
            setIsReadOnly(false);
          }
        } else {
          setIsCPA(false);
          setIsReadOnly(false);
          setUserEmail(null);
        }
      } catch {
        setIsCPA(false);
        setIsReadOnly(false);
        setUserEmail(null);
      } finally {
        setLoading(false);
      }
    };

    checkRole();
  }, []);

  // Log CPA access to zbooks_audit_log
  const logCPAAccess = useCallback(async (tableName: string, recordId?: string) => {
    try {
      const supabase = getSupabase();
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      await supabase
        .from('zbooks_audit_log')
        .insert({
          user_id: user.id,
          action: 'cpa_access',
          table_name: tableName,
          record_id: recordId || null,
          metadata: {
            email: user.email,
            role: user.app_metadata?.role || 'unknown',
            accessed_at: new Date().toISOString(),
          },
        });
    } catch {
      // Silent fail — audit log should not disrupt UX
    }
  }, []);

  // Generate export package for a date range
  const exportPackage = useCallback(async (
    dateRange: { startDate: string; endDate: string },
  ): Promise<ExportPackageData | null> => {
    try {
      const supabase = getSupabase();
      const { data: { user } } = await supabase.auth.getUser();
      const email = user?.email || 'unknown';
      const generatedAt = new Date().toISOString();
      const watermark = `Generated by ${email} on ${new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })} via ZAFTO ZBooks`;

      // Fetch all active accounts
      const { data: accounts } = await supabase
        .from('chart_of_accounts')
        .select('id, account_number, account_name, account_type, normal_balance')
        .eq('is_active', true)
        .order('account_number');

      if (!accounts) return null;

      const typedAccounts = accounts as {
        id: string;
        account_number: string;
        account_name: string;
        account_type: string;
        normal_balance: string;
      }[];

      // Fetch journal entry lines for the date range
      const { data: lines } = await supabase
        .from('journal_entry_lines')
        .select('account_id, debit_amount, credit_amount, journal_entries!inner(entry_date, status)')
        .eq('journal_entries.status', 'posted')
        .gte('journal_entries.entry_date', dateRange.startDate)
        .lte('journal_entries.entry_date', dateRange.endDate);

      // Aggregate by account
      const totals: Record<string, { debits: number; credits: number }> = {};
      for (const line of (lines || []) as Record<string, unknown>[]) {
        const accountId = line.account_id as string;
        if (!totals[accountId]) {
          totals[accountId] = { debits: 0, credits: 0 };
        }
        totals[accountId].debits += Number(line.debit_amount) || 0;
        totals[accountId].credits += Number(line.credit_amount) || 0;
      }

      const accountRows: ExportAccountRow[] = typedAccounts.map(acct => {
        const t = totals[acct.id] || { debits: 0, credits: 0 };
        const balance = acct.normal_balance === 'debit'
          ? t.debits - t.credits
          : t.credits - t.debits;
        return {
          accountNumber: acct.account_number,
          accountName: acct.account_name,
          accountType: acct.account_type,
          debits: Math.round(t.debits * 100) / 100,
          credits: Math.round(t.credits * 100) / 100,
          balance: Math.round(balance * 100) / 100,
        };
      });

      // -- P&L --
      const revenue = accountRows.filter(a => a.accountType === 'revenue');
      const cogs = accountRows.filter(a => a.accountType === 'cogs');
      const expenses = accountRows.filter(a => a.accountType === 'expense');
      const totalRevenue = revenue.reduce((s, a) => s + a.balance, 0);
      const totalCogs = cogs.reduce((s, a) => s + a.balance, 0);
      const grossProfit = totalRevenue - totalCogs;
      const totalExpenses = expenses.reduce((s, a) => s + a.balance, 0);
      const netIncome = grossProfit - totalExpenses;

      // -- Balance Sheet (cumulative, from beginning of time to endDate) --
      const { data: bsLines } = await supabase
        .from('journal_entry_lines')
        .select('account_id, debit_amount, credit_amount, journal_entries!inner(entry_date, status)')
        .eq('journal_entries.status', 'posted')
        .lte('journal_entries.entry_date', dateRange.endDate);

      const bsTotals: Record<string, { debits: number; credits: number }> = {};
      for (const line of (bsLines || []) as Record<string, unknown>[]) {
        const accountId = line.account_id as string;
        if (!bsTotals[accountId]) {
          bsTotals[accountId] = { debits: 0, credits: 0 };
        }
        bsTotals[accountId].debits += Number(line.debit_amount) || 0;
        bsTotals[accountId].credits += Number(line.credit_amount) || 0;
      }

      const bsAccountRows: ExportAccountRow[] = typedAccounts.map(acct => {
        const t = bsTotals[acct.id] || { debits: 0, credits: 0 };
        const balance = acct.normal_balance === 'debit'
          ? t.debits - t.credits
          : t.credits - t.debits;
        return {
          accountNumber: acct.account_number,
          accountName: acct.account_name,
          accountType: acct.account_type,
          debits: Math.round(t.debits * 100) / 100,
          credits: Math.round(t.credits * 100) / 100,
          balance: Math.round(balance * 100) / 100,
        };
      });

      const assets = bsAccountRows.filter(a => a.accountType === 'asset');
      const liabilities = bsAccountRows.filter(a => a.accountType === 'liability');
      const equity = bsAccountRows.filter(a => a.accountType === 'equity');
      const totalAssets = assets.reduce((s, a) => s + a.balance, 0);
      const totalLiabilities = liabilities.reduce((s, a) => s + a.balance, 0);
      const totalEquity = equity.reduce((s, a) => s + a.balance, 0) + netIncome;

      // -- Trial Balance (cumulative to endDate) --
      const tbAccounts = bsAccountRows.filter(a => a.debits > 0 || a.credits > 0 || a.balance !== 0);
      let debitTotal = 0;
      let creditTotal = 0;
      for (const a of bsAccountRows) {
        const acctMeta = typedAccounts.find(ta => ta.account_number === a.accountNumber);
        const normalBalance = acctMeta?.normal_balance || 'debit';
        if (a.balance >= 0) {
          if (normalBalance === 'debit') debitTotal += a.balance;
          else creditTotal += a.balance;
        } else {
          if (normalBalance === 'debit') creditTotal += Math.abs(a.balance);
          else debitTotal += Math.abs(a.balance);
        }
      }

      // -- 1099 Vendors --
      const year = dateRange.startDate.substring(0, 4);
      const startOfYear = `${year}-01-01`;
      const endOfYear = `${year}-12-31`;

      const { data: vendorData } = await supabase
        .from('vendors')
        .select('id, vendor_name, tax_id, is_1099_eligible')
        .eq('is_1099_eligible', true)
        .is('deleted_at', null)
        .order('vendor_name');

      const { data: paymentData } = await supabase
        .from('vendor_payments')
        .select('vendor_id, amount')
        .gte('payment_date', startOfYear)
        .lte('payment_date', endOfYear);

      const ytdMap = new Map<string, number>();
      for (const p of (paymentData || []) as { vendor_id: string; amount: number }[]) {
        ytdMap.set(p.vendor_id, (ytdMap.get(p.vendor_id) || 0) + Number(p.amount));
      }

      const vendors1099: Export1099Vendor[] = ((vendorData || []) as {
        id: string;
        vendor_name: string;
        tax_id: string | null;
        is_1099_eligible: boolean;
      }[]).map(v => ({
        vendorName: v.vendor_name,
        taxId: v.tax_id,
        ytdPayments: ytdMap.get(v.id) || 0,
        is1099Required: (ytdMap.get(v.id) || 0) >= 600,
      }));

      const totalVendorPayments = vendors1099.reduce((s, v) => s + v.ytdPayments, 0);
      const vendorsOver600 = vendors1099.filter(v => v.is1099Required);

      // Log the export access
      await logCPAAccess('export_package');

      return {
        pnl: {
          revenue,
          cogs,
          expenses,
          totalRevenue: Math.round(totalRevenue * 100) / 100,
          totalCogs: Math.round(totalCogs * 100) / 100,
          grossProfit: Math.round(grossProfit * 100) / 100,
          totalExpenses: Math.round(totalExpenses * 100) / 100,
          netIncome: Math.round(netIncome * 100) / 100,
        },
        balanceSheet: {
          assets,
          liabilities,
          equity,
          totalAssets: Math.round(totalAssets * 100) / 100,
          totalLiabilities: Math.round(totalLiabilities * 100) / 100,
          totalEquity: Math.round(totalEquity * 100) / 100,
        },
        trialBalance: {
          accounts: tbAccounts,
          debitTotal: Math.round(debitTotal * 100) / 100,
          creditTotal: Math.round(creditTotal * 100) / 100,
          isBalanced: Math.abs(debitTotal - creditTotal) < 0.01,
        },
        vendors1099: {
          vendors: vendorsOver600,
          totalPayments: Math.round(totalVendorPayments * 100) / 100,
          vendorCount: vendorsOver600.length,
        },
        watermark,
        generatedAt,
        dateRange,
      };
    } catch (err) {
      console.error('Failed to generate export package:', err);
      return null;
    }
  }, [logCPAAccess]);

  // Generic CSV export utility
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const exportCSV = useCallback((
    data: any[],
    headers: { key: string; label: string }[],
    filename: string,
  ) => {
    if (data.length === 0) return;

    const headerRow = headers.map(h => escapeCSVValue(h.label)).join(',');
    const dataRows = data.map((row: Record<string, unknown>) =>
      headers.map(h => escapeCSVValue(row[h.key] as string | number | boolean | null)).join(',')
    );

    const csvContent = [headerRow, ...dataRows].join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
  }, []);

  return {
    isCPA,
    isReadOnly,
    userEmail,
    loading,
    logCPAAccess,
    exportPackage,
    exportCSV,
  };
}
